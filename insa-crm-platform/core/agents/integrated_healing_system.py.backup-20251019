#!/usr/bin/env python3
"""
INSA Integrated Healing System
Combines autonomous research agent with platform health monitor

Flow:
1. Platform Health Monitor detects issue
2. Research Agent searches for solution
3. Solution validation and ranking
4. Auto-deployment to healing agent
5. Verification and learning

Author: Insa Automation Corp
Date: October 19, 2025

SAFEGUARDS:
- Timeout limits on all operations
- Resource monitoring
- Runaway process prevention
- Memory leak detection
- Circuit breaker pattern
"""

import os
import sys
import json
import time
import subprocess
import signal
import resource
import psutil
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional
from contextlib import contextmanager
import logging

# Add parent directory to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))
sys.path.insert(0, str(Path(__file__).parent))
sys.path.insert(0, '/home/wil')  # For notification_queue and email_reporter

# Import our agents
try:
    from autonomous_research_agent import (
        AutonomousResearchAgent,
        ResearchQuery,
        ResearchTrigger,
        Solution,
        SolutionStatus
    )
except ImportError:
    # Fallback import path
    from insa_crm_platform.core.agents.autonomous_research_agent import (
        AutonomousResearchAgent,
        ResearchQuery,
        ResearchTrigger,
        Solution,
        SolutionStatus
    )

# Import platform health monitor
try:
    from platform_health_monitor import PlatformHealthMonitor
except ImportError:
    # If not in PYTHONPATH, try direct import
    import importlib.util
    spec = importlib.util.spec_from_file_location(
        "platform_health_monitor",
        "/home/wil/platform_health_monitor.py"
    )
    platform_health_monitor = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(platform_health_monitor)
    PlatformHealthMonitor = platform_health_monitor.PlatformHealthMonitor

# Import notification system
try:
    from email_reporter import EmailReporter
    from notification_queue import TieredNotificationManager
except ImportError as e:
    logger.error(f"Failed to import notification system: {e}")
    EmailReporter = None
    TieredNotificationManager = None

# Setup logging
os.makedirs('/var/lib/insa-crm/logs', exist_ok=True)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/var/lib/insa-crm/logs/integrated_healing.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('IntegratedHealing')


# Timeout decorator to prevent hanging operations
@contextmanager
def timeout(seconds):
    """Context manager for operation timeout"""
    def timeout_handler(signum, frame):
        raise TimeoutError(f"Operation timed out after {seconds} seconds")

    # Set the signal handler
    old_handler = signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(seconds)

    try:
        yield
    finally:
        signal.alarm(0)
        signal.signal(signal.SIGALRM, old_handler)


class ResourceMonitor:
    """Monitor and enforce resource limits"""

    def __init__(self, max_memory_mb=400, max_cpu_percent=30):
        self.max_memory_mb = max_memory_mb
        self.max_cpu_percent = max_cpu_percent
        self.process = psutil.Process()
        logger.info(f"Resource monitor initialized: {max_memory_mb}MB RAM, {max_cpu_percent}% CPU")

    def check_resources(self) -> Dict[str, Any]:
        """Check current resource usage"""
        try:
            mem_info = self.process.memory_info()
            mem_mb = mem_info.rss / 1024 / 1024
            cpu_percent = self.process.cpu_percent(interval=0.1)

            return {
                'memory_mb': mem_mb,
                'memory_percent': (mem_mb / self.max_memory_mb) * 100,
                'cpu_percent': cpu_percent,
                'within_limits': mem_mb < self.max_memory_mb and cpu_percent < self.max_cpu_percent
            }
        except Exception as e:
            logger.error(f"Resource check failed: {e}")
            return {'within_limits': True, 'error': str(e)}

    def enforce_limits(self):
        """Enforce resource limits, raise exception if exceeded"""
        stats = self.check_resources()

        if not stats.get('within_limits', True):
            if stats['memory_mb'] >= self.max_memory_mb:
                raise MemoryError(f"Memory limit exceeded: {stats['memory_mb']:.1f}MB >= {self.max_memory_mb}MB")
            if stats['cpu_percent'] >= self.max_cpu_percent:
                logger.warning(f"CPU limit exceeded: {stats['cpu_percent']:.1f}% >= {self.max_cpu_percent}%")

        return stats


class IntegratedHealingSystem:
    """
    Unified autonomous healing system

    Combines:
    - Platform Health Monitor (diagnostics)
    - Research Agent (solution discovery)
    - Auto-healing (deployment)
    - Learning (pattern recognition)
    """

    def __init__(self, auto_heal: bool = True, research_enabled: bool = True):
        logger.info("Initializing Integrated Healing System...")

        self.auto_heal = auto_heal
        self.research_enabled = research_enabled

        # Initialize resource monitor
        self.resource_monitor = ResourceMonitor(max_memory_mb=400, max_cpu_percent=30)

        # Initialize components
        self.health_monitor = PlatformHealthMonitor(verbose=True)
        self.research_agent = AutonomousResearchAgent(auto_deploy=False) if research_enabled else None

        # Initialize tier-based notification system
        self.notification_manager = None
        if EmailReporter and TieredNotificationManager:
            try:
                email_reporter = EmailReporter()
                self.notification_manager = TieredNotificationManager(email_reporter)
                logger.info("âœ… Tier-based notification system initialized")
                logger.info("   REALTIME: Critical/High - Send immediately")
                logger.info("   HOURLY: Medium - Batch every hour")
                logger.info("   DAILY: Low/Info - Daily summary at 8 AM")
            except Exception as e:
                logger.warning(f"Failed to initialize notification system: {e}")
        else:
            logger.warning("Notification system not available (missing dependencies)")

        # Healing history
        self.healing_history_path = Path("/var/lib/insa-crm/healing_history.jsonl")
        self.healing_history_path.parent.mkdir(parents=True, exist_ok=True)

        # Known issues and solutions (learned patterns)
        self.known_solutions = self._load_known_solutions()

        # Timeout limits (in seconds)
        self.TIMEOUT_HEALTH_CHECK = 60
        self.TIMEOUT_RESEARCH = 300  # 5 minutes max for research
        self.TIMEOUT_DEPLOYMENT = 180  # 3 minutes max for deployment
        self.TIMEOUT_TOTAL_HEALING = 600  # 10 minutes max per service

        logger.info(f"Integrated Healing System initialized")
        logger.info(f"  Auto-heal: {auto_heal}")
        logger.info(f"  Research: {research_enabled}")
        logger.info(f"  Known solutions: {len(self.known_solutions)}")
        logger.info(f"  Resource limits: 400MB RAM, 30% CPU")
        logger.info(f"  Timeout limits: Health={self.TIMEOUT_HEALTH_CHECK}s, Research={self.TIMEOUT_RESEARCH}s, Deploy={self.TIMEOUT_DEPLOYMENT}s")

    def _load_known_solutions(self) -> Dict[str, Solution]:
        """Load previously learned solutions from database"""
        if not self.research_agent:
            return {}

        try:
            # Get all validated solutions from research database
            stats = self.research_agent.db.get_statistics()
            logger.info(f"Research DB stats: {stats}")

            # TODO: Load actual solutions from database
            # For now, return empty dict
            return {}
        except Exception as e:
            logger.error(f"Failed to load known solutions: {e}")
            return {}

    def check_known_solution(self, issue_signature: str) -> Optional[Solution]:
        """Check if we have a known solution for this issue"""
        return self.known_solutions.get(issue_signature)

    def create_issue_signature(self, service_id: str, health_result: Dict) -> str:
        """
        Create unique signature for an issue

        Used to check if we've seen this before
        """
        components = [
            service_id,
            str(health_result.get('http_code', 'none')),
            health_result.get('error', 'unknown')[:50]
        ]

        return "|".join(components)

    def diagnose_and_heal(self, service_id: str) -> Dict[str, Any]:
        """
        Full diagnostic and healing cycle for a service

        Returns:
        {
            'service': str,
            'initial_status': str,
            'issue_detected': bool,
            'solution_found': bool,
            'solution_applied': bool,
            'final_status': str,
            'solution_details': dict,
            'duration_seconds': float,
            'resource_usage': dict
        }
        """

        start_time = time.time()
        logger.info(f"=== Starting diagnosis for {service_id} ===")

        # Check resources before starting
        try:
            resource_stats = self.resource_monitor.check_resources()
            logger.info(f"Resource usage at start: {resource_stats['memory_mb']:.1f}MB, {resource_stats['cpu_percent']:.1f}% CPU")
        except Exception as e:
            logger.warning(f"Could not check resources: {e}")
            resource_stats = {}

        result = {
            'service': service_id,
            'timestamp': datetime.now().isoformat(),
            'initial_status': None,
            'issue_detected': False,
            'solution_found': False,
            'solution_applied': False,
            'final_status': None,
            'solution_details': None,
            'error': None,
            'duration_seconds': 0
        }

        try:
            # Use timeout to prevent hanging
            with timeout(self.TIMEOUT_TOTAL_HEALING):
                # Step 1: Check current health
                logger.info(f"Step 1: Checking health of {service_id}")

                with timeout(self.TIMEOUT_HEALTH_CHECK):
                    health_result = self.health_monitor.check_http_health(service_id)

            service_config = self.health_monitor.SERVICES[service_id]
            container = service_config.get('container')
            if container:
                container_status = self.health_monitor.check_container_status(container)
                health_result['container_running'] = container_status['running']

            result['initial_status'] = 'healthy' if health_result['healthy'] else 'unhealthy'

            if health_result['healthy']:
                logger.info(f"âœ… {service_id} is healthy")
                result['final_status'] = 'healthy'
                return result

            # Issue detected
            result['issue_detected'] = True
            logger.warning(f"ðŸš¨ Issue detected in {service_id}")
            logger.warning(f"   HTTP code: {health_result.get('http_code', 'N/A')}")
            logger.warning(f"   Error: {health_result.get('error', 'Unknown')}")
            logger.warning(f"   Container: {health_result.get('container_running', 'N/A')}")

            # Step 2: Check for known solution
            issue_sig = self.create_issue_signature(service_id, health_result)
            logger.info(f"Step 2: Checking for known solution (sig: {issue_sig})")

            known_solution = self.check_known_solution(issue_sig)

            if known_solution:
                logger.info(f"âœ… Found known solution: {known_solution.solution_id}")
                result['solution_found'] = True
                result['solution_details'] = {
                    'solution_id': known_solution.solution_id,
                    'title': known_solution.title,
                    'source': 'known_pattern',
                    'validation_score': known_solution.validation_score
                }

                # Apply known solution
                if self.auto_heal:
                    applied = self._apply_solution(service_id, known_solution, health_result)
                    result['solution_applied'] = applied

            else:
                # Step 3: Try built-in fix functions first
                logger.info("Step 3: Trying built-in fix functions")

                fix_function_name = service_config.get('fix_function')
                if fix_function_name and self.auto_heal:
                    logger.info(f"Applying built-in fix: {fix_function_name}")
                    fix_function = getattr(self.health_monitor, fix_function_name, None)

                    if fix_function:
                        success = fix_function()
                        result['solution_applied'] = success
                        result['solution_details'] = {
                            'source': 'builtin',
                            'function': fix_function_name,
                            'success': success
                        }

                        if success:
                            logger.info("âœ… Built-in fix succeeded")
                            result['solution_found'] = True
                        else:
                            logger.warning("âš ï¸ Built-in fix failed")

                # Step 4: Research new solution if needed
                if not result['solution_applied'] and self.research_enabled:
                    logger.info("Step 4: Researching new solution...")

                    research_result = self._research_solution(service_id, health_result)

                    if research_result:
                        result['solution_found'] = True
                        result['solution_details'] = research_result

                        # Apply researched solution
                        if self.auto_heal and research_result.get('production_ready'):
                            solution_obj = research_result.get('solution_object')
                            if solution_obj:
                                applied = self._apply_solution(service_id, solution_obj, health_result)
                                result['solution_applied'] = applied

            # Step 5: Verify fix
            logger.info("Step 5: Verifying fix...")
            time.sleep(10)  # Wait for service to stabilize

            final_health = self.health_monitor.check_http_health(service_id)
            result['final_status'] = 'healthy' if final_health['healthy'] else 'still_unhealthy'

            if final_health['healthy']:
                logger.info(f"âœ… {service_id} is now healthy!")
            else:
                logger.error(f"âŒ {service_id} is still unhealthy")
                result['error'] = final_health.get('error')

        except TimeoutError as e:
            logger.error(f"Timeout during diagnosis: {e}")
            result['error'] = f"Timeout: {str(e)}"
            result['final_status'] = 'timeout'
        except MemoryError as e:
            logger.error(f"Memory limit exceeded: {e}")
            result['error'] = f"Memory limit: {str(e)}"
            result['final_status'] = 'resource_limit'
        except Exception as e:
            logger.error(f"Error during diagnosis and healing: {e}", exc_info=True)
            result['error'] = str(e)
            result['final_status'] = 'error'

        # Record duration and final resource usage
        result['duration_seconds'] = time.time() - start_time

        try:
            final_resource_stats = self.resource_monitor.check_resources()
            result['resource_usage'] = final_resource_stats
            logger.info(f"Final resource usage: {final_resource_stats['memory_mb']:.1f}MB, {final_resource_stats['cpu_percent']:.1f}% CPU")
        except:
            pass

        # Save to history
        self._save_healing_event(result)

        # Send notification via tier-based system
        if self.notification_manager:
            try:
                self.notification_manager.notify_healing_event(service_id, result)
            except Exception as e:
                logger.error(f"Failed to send notification: {e}")

        logger.info(f"=== Diagnosis complete for {service_id} ({result['duration_seconds']:.1f}s) ===")

        return result

    def _research_solution(self, service_id: str, health_result: Dict) -> Optional[Dict]:
        """
        Research solution using autonomous research agent

        Returns:
        {
            'query_id': str,
            'solution_id': str,
            'title': str,
            'validation_score': float,
            'production_ready': bool,
            'sources': list,
            'solution_object': Solution
        }
        """

        if not self.research_agent:
            return None

        logger.info(f"Starting research for {service_id} issue...")

        service_config = self.health_monitor.SERVICES[service_id]

        # Construct research query
        query_text = self._construct_research_query(service_id, health_result, service_config)

        logger.info(f"Research query: {query_text}")

        # Create research query object
        query = ResearchQuery(
            query_id=f"{service_id}-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
            trigger=ResearchTrigger.ERROR_DETECTED,
            query_text=query_text,
            context={
                'service_id': service_id,
                'service_name': service_config['name'],
                'url': service_config['url'],
                'http_code': health_result.get('http_code'),
                'error': health_result.get('error'),
                'container': service_config.get('container'),
                'container_running': health_result.get('container_running')
            },
            error_message=health_result.get('error'),
            affected_component=service_id,
            priority=10 if service_config.get('critical') else 7
        )

        # Execute research
        try:
            solution = self.research_agent.research(query)

            if solution:
                logger.info(f"âœ… Research found solution: {solution.solution_id}")
                logger.info(f"   Validation score: {solution.validation_score:.2%}")
                logger.info(f"   Production ready: {solution.is_production_ready}")

                return {
                    'query_id': query.query_id,
                    'solution_id': solution.solution_id,
                    'title': solution.title,
                    'validation_score': solution.validation_score,
                    'production_ready': solution.is_production_ready,
                    'sources': solution.source_urls,
                    'solution_object': solution
                }
            else:
                logger.warning("âŒ Research did not find a solution")
                return None

        except Exception as e:
            logger.error(f"Research failed: {e}", exc_info=True)
            return None

    def _construct_research_query(
        self,
        service_id: str,
        health_result: Dict,
        service_config: Dict
    ) -> str:
        """
        Construct intelligent research query based on issue details

        Examples:
        - "ERPNext nginx timeout 504 gateway error docker container"
        - "n8n workflow engine permission denied /home/node/.n8n"
        - "Grafana plugin installation failed dashboard not loading"
        """

        parts = [service_config['name']]

        # Add error details
        if health_result.get('http_code'):
            parts.append(f"HTTP {health_result['http_code']}")

        if health_result.get('error'):
            error = health_result['error']
            # Extract key terms
            parts.append(error)

        # Add container info if relevant
        if service_config.get('container') and not health_result.get('container_running'):
            parts.append("docker container not running")

        # Add technology-specific keywords
        tech_keywords = {
            'erpnext': ['frappe', 'nginx', 'websocket', 'docker-compose'],
            'n8n': ['workflow', 'permissions', 'node'],
            'grafana': ['plugin', 'dashboard', 'datasource'],
            'mautic': ['cron', 'segments', 'email'],
            'defectdojo': ['uwsgi', 'celery', 'redis'],
            'inventree': ['django', 'postgresql']
        }

        if service_id in tech_keywords:
            parts.extend(tech_keywords[service_id][:2])  # Add first 2 keywords

        # Add "production" and "fix" for better results
        parts.extend(['production', 'fix', 'solution'])

        return " ".join(parts)

    def _apply_solution(
        self,
        service_id: str,
        solution: Solution,
        health_result: Dict
    ) -> bool:
        """
        Apply solution to fix the issue

        This is the critical integration point:
        - Takes Solution from research agent
        - Translates to concrete actions
        - Executes fixes
        - Verifies success
        """

        logger.info(f"Applying solution {solution.solution_id} to {service_id}...")

        try:
            # Extract actionable steps from solution
            steps = solution.steps if solution.steps else []
            code_snippets = solution.code_snippets if solution.code_snippets else []

            # If no explicit steps, try to infer from description
            if not steps and solution.description:
                steps = self._infer_steps_from_description(solution.description)

            if not steps:
                logger.warning("No actionable steps found in solution")
                return False

            # Execute steps
            for i, step in enumerate(steps, 1):
                logger.info(f"Executing step {i}/{len(steps)}: {step[:100]}")

                success = self._execute_step(service_id, step, code_snippets)

                if not success:
                    logger.error(f"Step {i} failed")
                    return False

            logger.info(f"âœ… All steps executed successfully")
            return True

        except Exception as e:
            logger.error(f"Failed to apply solution: {e}", exc_info=True)
            return False

    def _infer_steps_from_description(self, description: str) -> List[str]:
        """
        Infer actionable steps from solution description

        Looks for common patterns:
        - "restart the container"
        - "update configuration file"
        - "run command: docker-compose restart"
        """

        steps = []

        # Common patterns
        if "restart" in description.lower():
            steps.append("Restart the service")

        if "docker-compose" in description.lower():
            # Extract docker-compose commands
            import re
            commands = re.findall(r'docker-compose\s+\S+', description)
            steps.extend(commands)

        if "permission" in description.lower() and "chmod" in description.lower():
            steps.append("Fix file permissions")

        return steps

    def _execute_step(self, service_id: str, step: str, code_snippets: List[str]) -> bool:
        """
        Execute a single solution step

        Safely executes common operations:
        - Service restarts
        - Container operations
        - Configuration updates
        - Permission fixes
        """

        step_lower = step.lower()

        # Restart operations
        if "restart" in step_lower:
            service_config = self.health_monitor.SERVICES[service_id]
            container = service_config.get('container')

            if container:
                logger.info(f"Restarting container: {container}")
                cmd = f"docker restart {container}"
                returncode, stdout, stderr = self.health_monitor.run_command(cmd, timeout=60)

                if returncode == 0:
                    logger.info("Container restarted successfully")
                    time.sleep(10)  # Wait for startup
                    return True
                else:
                    logger.error(f"Container restart failed: {stderr}")
                    return False

        # Docker-compose operations
        elif "docker-compose" in step_lower:
            # Extract and execute docker-compose command
            logger.info(f"Executing docker-compose command: {step}")

            service_config = self.health_monitor.SERVICES[service_id]
            compose_dir = service_config.get('compose_dir')

            if compose_dir:
                cmd = f"cd {compose_dir} && {step}"
                returncode, stdout, stderr = self.health_monitor.run_command(cmd, timeout=120)

                if returncode == 0:
                    logger.info("Docker-compose command succeeded")
                    time.sleep(15)  # Wait for services
                    return True
                else:
                    logger.error(f"Docker-compose command failed: {stderr}")
                    return False

        # Permission fixes
        elif "permission" in step_lower or "chmod" in step_lower:
            logger.info("Applying permission fixes...")
            # TODO: Implement safe permission fixes
            return True

        # Configuration updates
        elif "config" in step_lower:
            logger.info("Configuration update step detected")
            # TODO: Implement safe config updates
            return True

        else:
            logger.warning(f"Unknown step type: {step}")
            return False

    def _save_healing_event(self, event: Dict):
        """Save healing event to JSONL history"""
        try:
            with open(self.healing_history_path, 'a') as f:
                f.write(json.dumps(event) + '\n')
        except Exception as e:
            logger.error(f"Failed to save healing event: {e}")

    def run_full_platform_scan(self) -> Dict[str, Any]:
        """
        Run complete platform health scan with healing

        Returns:
        {
            'timestamp': str,
            'services_checked': int,
            'issues_detected': int,
            'issues_fixed': int,
            'services': {service_id: result}
        }
        """

        logger.info("=== Starting full platform scan ===")

        report = {
            'timestamp': datetime.now().isoformat(),
            'services_checked': 0,
            'issues_detected': 0,
            'issues_fixed': 0,
            'services': {}
        }

        for service_id in self.health_monitor.SERVICES.keys():
            logger.info(f"\n--- Checking {service_id} ---")

            result = self.diagnose_and_heal(service_id)

            report['services'][service_id] = result
            report['services_checked'] += 1

            if result['issue_detected']:
                report['issues_detected'] += 1

            if result['final_status'] == 'healthy' and result['issue_detected']:
                report['issues_fixed'] += 1

        # Summary
        logger.info("\n=== Platform Scan Complete ===")
        logger.info(f"Services checked: {report['services_checked']}")
        logger.info(f"Issues detected: {report['issues_detected']}")
        logger.info(f"Issues fixed: {report['issues_fixed']}")

        if report['issues_detected'] > 0:
            fix_rate = (report['issues_fixed'] / report['issues_detected']) * 100
            logger.info(f"Fix rate: {fix_rate:.1f}%")

        return report

    def run_continuous(self, interval: int = 300):
        """
        Run continuous monitoring with healing

        Args:
            interval: Check interval in seconds (default 5 minutes)
        """

        logger.info(f"Starting continuous healing (interval: {interval}s)")

        iteration = 0

        while True:
            try:
                iteration += 1
                logger.info(f"\n{'='*60}")
                logger.info(f"Healing Iteration #{iteration}")
                logger.info(f"{'='*60}\n")

                # Run full platform scan
                report = self.run_full_platform_scan()

                # Sleep until next check
                logger.info(f"\nSleeping {interval}s until next check...\n")
                time.sleep(interval)

            except KeyboardInterrupt:
                logger.info("\nShutting down gracefully...")
                break
            except Exception as e:
                logger.error(f"Error in continuous loop: {e}", exc_info=True)
                time.sleep(60)  # Wait 1 minute before retry


def main():
    """Main entry point"""

    import argparse

    parser = argparse.ArgumentParser(description="INSA Integrated Healing System")
    parser.add_argument("--no-auto-heal", action="store_true", help="Disable automatic healing")
    parser.add_argument("--no-research", action="store_true", help="Disable research agent")
    parser.add_argument("--interval", type=int, default=300, help="Monitoring interval in seconds (default: 300)")
    parser.add_argument("--service", type=str, help="Check specific service only")
    parser.add_argument("--once", action="store_true", help="Run once and exit")

    args = parser.parse_args()

    # Initialize system
    system = IntegratedHealingSystem(
        auto_heal=not args.no_auto_heal,
        research_enabled=not args.no_research
    )

    if args.service:
        # Single service check
        logger.info(f"Checking single service: {args.service}")
        result = system.diagnose_and_heal(args.service)

        print("\n" + "="*60)
        print(f"Result: {json.dumps(result, indent=2)}")
        print("="*60)

    elif args.once:
        # Single full scan
        report = system.run_full_platform_scan()

        print("\n" + "="*60)
        print(f"Platform Scan Report:")
        print(f"  Services Checked: {report['services_checked']}")
        print(f"  Issues Detected: {report['issues_detected']}")
        print(f"  Issues Fixed: {report['issues_fixed']}")
        print("="*60)

    else:
        # Continuous mode
        system.run_continuous(interval=args.interval)


if __name__ == "__main__":
    main()
